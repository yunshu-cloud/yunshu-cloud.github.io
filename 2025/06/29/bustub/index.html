<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="Project 0 Primer1. C++ basicstd::string vs std::string_viewstd::stringkeys of features  dynamic memory allocation mutable operation wide range of member functions  std::string_viewkeys of features  no">
<meta property="og:type" content="article">
<meta property="og:title" content="bustub">
<meta property="og:url" content="http://example.com/2025/06/29/bustub/index.html">
<meta property="og:site_name" content="VictorHolmes Blog">
<meta property="og:description" content="Project 0 Primer1. C++ basicstd::string vs std::string_viewstd::stringkeys of features  dynamic memory allocation mutable operation wide range of member functions  std::string_viewkeys of features  no">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/06/29/bustub/buildProblem.png">
<meta property="og:image" content="http://example.com/2025/06/29/bustub/trie-example.png">
<meta property="og:image" content="http://example.com/2025/06/29/bustub/trie_path.png">
<meta property="article:published_time" content="2025-06-29T06:06:55.000Z">
<meta property="article:modified_time" content="2025-06-29T13:47:01.531Z">
<meta property="article:author" content="victor holmes">
<meta property="article:tag" content="test">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/06/29/bustub/buildProblem.png">


<link rel="canonical" href="http://example.com/2025/06/29/bustub/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2025/06/29/bustub/","path":"2025/06/29/bustub/","title":"bustub"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>bustub | VictorHolmes Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">VictorHolmes Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Hexo Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Project-0-Primer"><span class="nav-number">1.</span> <span class="nav-text">Project 0 Primer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-C-basic"><span class="nav-number">1.1.</span> <span class="nav-text">1. C++ basic</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#std-string-vs-std-string-view"><span class="nav-number">1.1.1.</span> <span class="nav-text">std::string vs std::string_view</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#std-lock-guard-and-std-mutex"><span class="nav-number">1.1.2.</span> <span class="nav-text">std::lock_guard and std::mutex</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generate-executable-program"><span class="nav-number">1.2.</span> <span class="nav-text">Generate executable program</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Primer-level"><span class="nav-number">1.3.</span> <span class="nav-text">Primer level</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Trie"><span class="nav-number">1.3.1.</span> <span class="nav-text">Trie</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Core-Trie-Immutable"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">Core Trie (Immutable)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TrieStore-Thread-Safe-Wrapper"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">TrieStore (Thread-Safe Wrapper)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Test"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">Test</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">victor holmes</p>
  <div class="site-description" itemprop="description">Hei guys, Welcome to my Blog :)</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/29/bustub/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="victor holmes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VictorHolmes Blog">
      <meta itemprop="description" content="Hei guys, Welcome to my Blog :)">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="bustub | VictorHolmes Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          bustub
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-06-29 14:06:55 / Modified: 21:47:01" itemprop="dateCreated datePublished" datetime="2025-06-29T14:06:55+08:00">2025-06-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h3 id="Project-0-Primer"><a href="#Project-0-Primer" class="headerlink" title="Project 0 Primer"></a>Project 0 Primer</h3><h4 id="1-C-basic"><a href="#1-C-basic" class="headerlink" title="1. C++ basic"></a>1. C++ basic</h4><h5 id="std-string-vs-std-string-view"><a href="#std-string-vs-std-string-view" class="headerlink" title="std::string vs std::string_view"></a><em>std::string vs std::string_view</em></h5><p><strong>std::string</strong><br>keys of features</p>
<ul>
<li>dynamic memory allocation</li>
<li>mutable operation</li>
<li>wide range of member functions</li>
</ul>
<p><strong>std::string_view</strong><br>keys of features</p>
<ul>
<li>non-owing view : provide view or reference to an existing string</li>
<li>light weight and efficient : assign or copy string_view is fast cause it only need to consider the reference ,length and start position of the string</li>
<li>immutable operations : if someone just need to read the string ,should use the std::string_view</li>
</ul>
<h5 id="std-lock-guard-and-std-mutex"><a href="#std-lock-guard-and-std-mutex" class="headerlink" title="std::lock_guard and std::mutex"></a><em>std::lock_guard and std::mutex</em></h5><p><strong>std::mutex</strong><br>A std::mutex (short for “mutual exclusion”) is a synchronization primitive used to protect shared data from being accessed concurrently by multiple threads.<br>std::mutex example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();  <span class="comment">// Lock the mutex</span></span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();  <span class="comment">// Unlock the mutex</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 2&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>std::lock_guard</strong><br>std::lock_guard is a RAII-style (Resource Acquisition Is Initialization) wrapper for std::mutex. It automatically locks the mutex when it’s constructed and unlocks it when it goes out of scope.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;  <span class="comment">// Mutex is locked here</span></span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// Mutex will automatically be unlocked when guard goes out of scope</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 2&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Generate-executable-program"><a href="#Generate-executable-program" class="headerlink" title="Generate executable program"></a>Generate executable program</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># First, git clone the project from the github or you could fork this to your own repository and then pull the project</span></span><br><span class="line">$ git <span class="built_in">clone</span> --bare https://github.com/cmu-db/bustub.git bustub-public</span><br><span class="line"></span><br><span class="line"><span class="comment"># Second, go to the directory of the repository,the name if not fixed if you pull your own project</span></span><br><span class="line">$ <span class="built_in">cd</span> bustub-public</span><br><span class="line"></span><br><span class="line"><span class="comment"># Third, build the project</span></span><br><span class="line">$ <span class="built_in">mkdir</span> build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>

<p>when on the third step,you could meet some problem which i met in my mac computer which is located at the third_party directory under the project root path.The detail is that the minimum version of the makefile should be 3.5 rather than 3.0. This problem only occur in my mac,but when it build in the linux, it disappear.</p>
<p><img src="/2025/06/29/bustub/buildProblem.png" alt="build-problem"></p>
<h4 id="Primer-level"><a href="#Primer-level" class="headerlink" title="Primer level"></a>Primer level</h4><p>This conclude the basic structure of the project which contains Trie ,SkipList, Hyperloglog, ORSet</p>
<h5 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h5><p>Tries — or prefix trees — are useful for sequential word search. Common features like autocomplete or spell-checking are more efficient when implemented with a prefix tree.</p>
<p>Here’s the structure of Tries:<br><img src="/2025/06/29/bustub/trie-example.png" alt="trie-structure"></p>
<p>Trie Implementation</p>
<h6 id="Core-Trie-Immutable"><a href="#Core-Trie-Immutable" class="headerlink" title="Core Trie (Immutable)"></a>Core Trie (Immutable)</h6><p>The path is as following:<br><img src="/2025/06/29/bustub/trie_path.png" alt="trie source path"></p>
<ul>
<li>Get(key) → Find value by key</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Trie::Get</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; <span class="type">const</span> T * </span>&#123;</span><br><span class="line">  <span class="comment">// Start from root</span></span><br><span class="line">  <span class="keyword">auto</span> current_node = root_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Walk through the trie following the key characters</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> c : key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = current_node-&gt;children_.<span class="built_in">find</span>(c);</span><br><span class="line">    <span class="keyword">if</span> (it == current_node-&gt;children_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current_node = it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if we found a node and if it has a value</span></span><br><span class="line">  <span class="keyword">if</span> (current_node == <span class="literal">nullptr</span> || !current_node-&gt;is_value_node_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try to cast to the expected type</span></span><br><span class="line">  <span class="keyword">auto</span> node_with_value = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;T&gt;*&gt;(current_node.<span class="built_in">get</span>());</span><br><span class="line">  <span class="keyword">if</span> (node_with_value == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// Type mismatch</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> node_with_value-&gt;value_.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Put(key, value) → Insert&#x2F;update (creates new trie)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Trie::Put</span><span class="params">(std::string_view key, T value)</span> <span class="type">const</span> -&gt; Trie </span>&#123;</span><br><span class="line">  <span class="comment">// Note that `T` might be a non-copyable type. Always use `std::move` when creating `shared_ptr` on that value.</span></span><br><span class="line"><span class="comment">//  throw NotImplementedException(&quot;Trie::Put is not implemented.&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// You should walk through the trie and create new nodes if necessary. If the node corresponding to the key already</span></span><br><span class="line">  <span class="comment">// exists, you should create a new `TrieNodeWithValue`.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> value_ptr = std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">  std::function&lt;std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;(std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;, std::string_view)&gt; put_recursive =</span><br><span class="line">      [&amp;](std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; current_node, std::string_view remaining_key) -&gt; std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; &#123;</span><br><span class="line">    <span class="comment">// Base case: we&#x27;ve consumed all characters in the key</span></span><br><span class="line">    <span class="keyword">if</span>(remaining_key.<span class="built_in">empty</span>())&#123;</span><br><span class="line">      <span class="keyword">if</span>(current_node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// create a new TrieNode with no children</span></span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;T&gt;&gt;(value_ptr);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// create a new TrieNodeWithValue with existing children but new/updated value</span></span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;T&gt;&gt;(current_node-&gt;children_, value_ptr);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursive case: consume one character and recurse</span></span><br><span class="line">    <span class="type">char</span> next_char = remaining_key[<span class="number">0</span>];</span><br><span class="line">    std::string_view rest_key = remaining_key.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Get current children (or empty map if no current node)</span></span><br><span class="line">    std::map&lt;<span class="type">char</span>, std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;&gt; new_children;</span><br><span class="line">    <span class="keyword">if</span>(current_node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      new_children = current_node-&gt;children_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the child for the next character</span></span><br><span class="line">    <span class="keyword">auto</span> child_it = new_children.<span class="built_in">find</span>(next_char); <span class="comment">// when meeting the crossroad,choose corresponding child</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; child_node = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(child_it != new_children.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      child_node = child_it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursively process the child</span></span><br><span class="line">    new_children[next_char] = <span class="built_in">put_recursive</span>(child_node, rest_key);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the path node here</span></span><br><span class="line">    <span class="comment">// Create a new node with the updated children</span></span><br><span class="line">    <span class="keyword">if</span> (current_node == <span class="literal">nullptr</span> || !current_node-&gt;is_value_node_) &#123;</span><br><span class="line">      <span class="comment">// No current node or current node has no value -&gt; create regular TrieNode</span></span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> TrieNode&gt;(std::<span class="built_in">move</span>(new_children));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Current node has a value -&gt; we need to preserve it while updating children</span></span><br><span class="line">      <span class="comment">// We&#x27;ll try to cast to the known instantiated types and preserve the value</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Try uint32_t</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_uint32 = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;<span class="type">uint32_t</span>&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;<span class="type">uint32_t</span>&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_uint32-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try uint64_t</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_uint64 = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;<span class="type">uint64_t</span>&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;<span class="type">uint64_t</span>&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_uint64-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try std::string</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_string = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;std::string&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;std::string&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_string-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try std::unique_ptr&lt;uint32_t&gt;</span></span><br><span class="line">      <span class="keyword">using</span> Integer = std::unique_ptr&lt;<span class="type">uint32_t</span>&gt;;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_int_ptr = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;Integer&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;Integer&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_int_ptr-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try MoveBlocked</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_move_blocked = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;MoveBlocked&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;MoveBlocked&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_move_blocked-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If none of the known types match, create a regular TrieNode (losing the value)</span></span><br><span class="line">      <span class="comment">// This shouldn&#x27;t happen with the current explicit instantiations</span></span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> TrieNode&gt;(std::<span class="built_in">move</span>(new_children));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Remove(key) → Delete key (creates new trie)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Trie::Remove</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; Trie </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// Empty trie, nothing to remove</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::function&lt;std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;(std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;, std::string_view)&gt; remove_recursive =</span><br><span class="line">      [&amp;](std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; current_node, std::string_view remaining_key) -&gt; std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If current node is null, key doesn&#x27;t exist</span></span><br><span class="line">    <span class="keyword">if</span> (current_node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Base case: we&#x27;ve consumed all characters in the key</span></span><br><span class="line">    <span class="keyword">if</span> (remaining_key.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="comment">// This is the node we want to remove the value from</span></span><br><span class="line">      <span class="keyword">if</span> (!current_node-&gt;is_value_node_) &#123;</span><br><span class="line">        <span class="comment">// Key doesn&#x27;t exist (no value at this node)</span></span><br><span class="line">        <span class="keyword">return</span> current_node;  <span class="comment">// Return unchanged</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Remove the value by converting to regular TrieNode</span></span><br><span class="line">      <span class="keyword">if</span> (current_node-&gt;children_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// No children, remove this node entirely</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Has children, keep as regular TrieNode without value</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> TrieNode&gt;(current_node-&gt;children_);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursive case: consume one character and recurse</span></span><br><span class="line">    <span class="type">char</span> next_char = remaining_key[<span class="number">0</span>];</span><br><span class="line">    std::string_view rest_key = remaining_key.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the child for the next character</span></span><br><span class="line">    <span class="keyword">auto</span> child_it = current_node-&gt;children_.<span class="built_in">find</span>(next_char);</span><br><span class="line">    <span class="keyword">if</span> (child_it == current_node-&gt;children_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="comment">// Key doesn&#x27;t exist</span></span><br><span class="line">      <span class="keyword">return</span> current_node;  <span class="comment">// Return unchanged</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively process the child</span></span><br><span class="line">    <span class="keyword">auto</span> new_child = <span class="built_in">remove_recursive</span>(child_it-&gt;second, rest_key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create new children map</span></span><br><span class="line">    std::map&lt;<span class="type">char</span>, std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;&gt; new_children = current_node-&gt;children_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (new_child == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// Child was removed, remove it from children map</span></span><br><span class="line">      new_children.<span class="built_in">erase</span>(next_char);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Update the child</span></span><br><span class="line">      new_children[next_char] = new_child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decide what to return based on current node&#x27;s state</span></span><br><span class="line">    <span class="keyword">if</span> (current_node-&gt;is_value_node_) &#123;</span><br><span class="line">      <span class="comment">// Current node has a value, preserve it with updated children</span></span><br><span class="line">      <span class="comment">// Try to cast to the known instantiated types and preserve the value</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Try uint32_t</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_uint32 = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;<span class="type">uint32_t</span>&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;<span class="type">uint32_t</span>&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_uint32-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try uint64_t</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_uint64 = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;<span class="type">uint64_t</span>&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;<span class="type">uint64_t</span>&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_uint64-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try std::string</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_string = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;std::string&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;std::string&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_string-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try std::unique_ptr&lt;uint32_t&gt;</span></span><br><span class="line">      <span class="keyword">using</span> Integer = std::unique_ptr&lt;<span class="type">uint32_t</span>&gt;;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_int_ptr = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;Integer&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;Integer&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_int_ptr-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try MoveBlocked</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_move_blocked = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;MoveBlocked&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;MoveBlocked&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_move_blocked-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Fallback - create regular TrieNode (shouldn&#x27;t happen with explicit instantiations)</span></span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> TrieNode&gt;(std::<span class="built_in">move</span>(new_children));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Current node has no value</span></span><br><span class="line">      <span class="keyword">if</span> (new_children.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// No value and no children, remove this node</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No value but has children, keep as regular TrieNode</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> TrieNode&gt;(std::<span class="built_in">move</span>(new_children));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> new_root = <span class="built_in">remove_recursive</span>(root_, key);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Trie</span>(new_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="TrieStore-Thread-Safe-Wrapper"><a href="#TrieStore-Thread-Safe-Wrapper" class="headerlink" title="TrieStore (Thread-Safe Wrapper)"></a>TrieStore (Thread-Safe Wrapper)</h6><p>Get(key) → Thread-safe read with ValueGuard</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">TrieStore::Get</span><span class="params">(std::string_view key)</span> -&gt; std::optional&lt;ValueGuard&lt;T&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// Pseudo-code:</span></span><br><span class="line">  <span class="comment">// (1) Take the root lock, get the root, and release the root lock. Don&#x27;t lookup the value in the</span></span><br><span class="line">  <span class="comment">//     trie while holding the root lock.</span></span><br><span class="line">  Trie root_snapshot;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root_snapshot = root_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// (2) Lookup the value in the trie.</span></span><br><span class="line">  <span class="type">const</span> T* value_ptr = root_snapshot.<span class="built_in">Get</span>&lt;T&gt;(key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (3) If the value is found, return a ValueGuard object that holds a reference to the value and the</span></span><br><span class="line">  <span class="comment">//     root. Otherwise, return std::nullopt.</span></span><br><span class="line">  <span class="keyword">if</span>(value_ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ValueGuard</span>&lt;T&gt;(std::<span class="built_in">move</span>(root_snapshot), *value_ptr);</span><br><span class="line"><span class="comment">//  throw NotImplementedException(&quot;TrieStore::Get is not implemented.&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Put(key, value) → Thread-safe write</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieStore::Put</span><span class="params">(std::string_view key, T value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// You will need to ensure there is only one writer at a time. Think of how you can achieve this.</span></span><br><span class="line">  <span class="comment">// The logic should be somehow similar to `TrieStore::Get`.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Acquire the write lock to ensure only one writer at a time</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">write_guard</span><span class="params">(write_lock_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the current root</span></span><br><span class="line">  Trie current_root;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">root_guard</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    current_root = root_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create new trie with the inserted value</span></span><br><span class="line">  Trie new_root = current_root.<span class="built_in">Put</span>&lt;T&gt;(key, std::<span class="built_in">move</span>(value));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the root</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">root_guard</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root_ = std::<span class="built_in">move</span>(new_root);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  throw NotImplementedException(&quot;TrieStore::Put is not implemented.&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Remove(key) → Thread-safe delete</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieStore::Remove</span><span class="params">(std::string_view key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// You will need to ensure there is only one writer at a time. Think of how you can achieve this.</span></span><br><span class="line">  <span class="comment">// The logic should be somehow similar to `TrieStore::Get`.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Acquire write lock to ensure only one writer at a time</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">write_guard</span><span class="params">(write_lock_)</span></span>;  <span class="comment">// to wait</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the current root</span></span><br><span class="line">  Trie current_root;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">root_guard</span><span class="params">(root_lock_)</span></span>; <span class="comment">// to wait</span></span><br><span class="line">    current_root = root_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create new trie with the key removed</span></span><br><span class="line">  Trie new_root = current_root.<span class="built_in">Remove</span>(key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the root</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">root_guard</span><span class="params">(root_lock_)</span></span>; <span class="comment">// to wait</span></span><br><span class="line">    root_ = std::<span class="built_in">move</span>(new_root);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  throw NotImplementedException(&quot;TrieStore::Remove is not implemented.&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h6><p>The current path is located at the root of the project</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">make trie_store_test trie_store_noncopy_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># Test basic functionality</span></span><br><span class="line">./test/trie_store_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Test with non-copyable types</span></span><br><span class="line">./test/trie_store_noncopy_test</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/06/16/CGLIB/" rel="prev" title="CGLIB">
                  <i class="fa fa-angle-left"></i> CGLIB
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">victor holmes</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
