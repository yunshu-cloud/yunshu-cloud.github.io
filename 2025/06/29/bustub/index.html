

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="victor holmes">
  <meta name="keywords" content="test">
  
    <meta name="description" content="Project 0 Primer1. C++ basicstd::string vs std::string_viewstd::stringkeys of features  dynamic memory allocation mutable operation wide range of member functions  std::string_viewkeys of features  no">
<meta property="og:type" content="article">
<meta property="og:title" content="bustub">
<meta property="og:url" content="http://example.com/2025/06/29/bustub/index.html">
<meta property="og:site_name" content="VictorHolmes Blog">
<meta property="og:description" content="Project 0 Primer1. C++ basicstd::string vs std::string_viewstd::stringkeys of features  dynamic memory allocation mutable operation wide range of member functions  std::string_viewkeys of features  no">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/06/29/bustub/buildProblem.png">
<meta property="og:image" content="http://example.com/2025/06/29/bustub/trie-example.png">
<meta property="og:image" content="http://example.com/2025/06/29/bustub/trie_path.png">
<meta property="article:published_time" content="2025-06-29T06:06:55.000Z">
<meta property="article:modified_time" content="2025-06-29T07:45:18.522Z">
<meta property="article:author" content="victor holmes">
<meta property="article:tag" content="test">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2025/06/29/bustub/buildProblem.png">
  
  
  
  <title>bustub - VictorHolmes Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="bustub"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-29 14:06" pubdate>
          June 29, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          1.2k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          11 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">bustub</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="Project-0-Primer"><a href="#Project-0-Primer" class="headerlink" title="Project 0 Primer"></a>Project 0 Primer</h3><h4 id="1-C-basic"><a href="#1-C-basic" class="headerlink" title="1. C++ basic"></a>1. C++ basic</h4><h5 id="std-string-vs-std-string-view"><a href="#std-string-vs-std-string-view" class="headerlink" title="std::string vs std::string_view"></a><em>std::string vs std::string_view</em></h5><p><strong>std::string</strong><br>keys of features</p>
<ul>
<li>dynamic memory allocation</li>
<li>mutable operation</li>
<li>wide range of member functions</li>
</ul>
<p><strong>std::string_view</strong><br>keys of features</p>
<ul>
<li>non-owing view : provide view or reference to an existing string</li>
<li>light weight and efficient : assign or copy string_view is fast cause it only need to consider the reference ,length and start position of the string</li>
<li>immutable operations : if someone just need to read the string ,should use the std::string_view</li>
</ul>
<h5 id="std-lock-guard-and-std-mutex"><a href="#std-lock-guard-and-std-mutex" class="headerlink" title="std::lock_guard and std::mutex"></a><em>std::lock_guard and std::mutex</em></h5><p><strong>std::mutex</strong><br>A std::mutex (short for “mutual exclusion”) is a synchronization primitive used to protect shared data from being accessed concurrently by multiple threads.<br>std::mutex example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span> </span>&#123;<br>    mtx.<span class="hljs-built_in">lock</span>();  <span class="hljs-comment">// Lock the mutex</span><br>    std::cout &lt;&lt; msg &lt;&lt; std::endl;<br>    mtx.<span class="hljs-built_in">unlock</span>();  <span class="hljs-comment">// Unlock the mutex</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(printMessage, <span class="hljs-string">&quot;Hello from thread 1&quot;</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(printMessage, <span class="hljs-string">&quot;Hello from thread 2&quot;</span>)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>std::lock_guard</strong><br>std::lock_guard is a RAII-style (Resource Acquisition Is Initialization) wrapper for std::mutex. It automatically locks the mutex when it’s constructed and unlocks it when it goes out of scope.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(mtx)</span></span>;  <span class="hljs-comment">// Mutex is locked here</span><br>    std::cout &lt;&lt; msg &lt;&lt; std::endl;<br>    <span class="hljs-comment">// Mutex will automatically be unlocked when guard goes out of scope</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(printMessage, <span class="hljs-string">&quot;Hello from thread 1&quot;</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(printMessage, <span class="hljs-string">&quot;Hello from thread 2&quot;</span>)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="Generate-executable-program"><a href="#Generate-executable-program" class="headerlink" title="Generate executable program"></a>Generate executable program</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># First, git clone the project from the github or you could fork this to your own repository and then pull the project</span><br>$ git <span class="hljs-built_in">clone</span> --bare https://github.com/cmu-db/bustub.git bustub-public<br><br><span class="hljs-comment"># Second, go to the directory of the repository,the name if not fixed if you pull your own project</span><br>$ <span class="hljs-built_in">cd</span> bustub-public<br><br><span class="hljs-comment"># Third, build the project</span><br>$ <span class="hljs-built_in">mkdir</span> build<br>$ <span class="hljs-built_in">cd</span> build<br>$ cmake ..<br>$ make<br></code></pre></td></tr></table></figure>

<p>when on the third step,you could meet some problem which i met in my mac computer which is located at the third_party directory under the project root path.The detail is that the minimum version of the makefile should be 3.5 rather than 3.0. This problem only occur in my mac,but when it build in the linux, it disappear.</p>
<p><img src="/2025/06/29/bustub/buildProblem.png" srcset="/img/loading.gif" lazyload alt="build-problem"></p>
<h4 id="Primer-level"><a href="#Primer-level" class="headerlink" title="Primer level"></a>Primer level</h4><p>This conclude the basic structure of the project which contains Trie ,SkipList, Hyperloglog, ORSet</p>
<h5 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h5><p>Tries — or prefix trees — are useful for sequential word search. Common features like autocomplete or spell-checking are more efficient when implemented with a prefix tree.</p>
<p>Here’s the structure of Tries:<br><img src="/2025/06/29/bustub/trie-example.png" srcset="/img/loading.gif" lazyload alt="trie-structure"></p>
<p>Trie Implementation</p>
<h6 id="Core-Trie-Immutable"><a href="#Core-Trie-Immutable" class="headerlink" title="Core Trie (Immutable)"></a>Core Trie (Immutable)</h6><p>The path is as following:<br><img src="/2025/06/29/bustub/trie_path.png" srcset="/img/loading.gif" lazyload alt="trie source path"></p>
<ul>
<li>Get(key) → Find value by key</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Trie::Get</span><span class="hljs-params">(std::string_view key)</span> <span class="hljs-type">const</span> -&gt; <span class="hljs-type">const</span> T * </span>&#123;<br>  <span class="hljs-comment">// Start from root</span><br>  <span class="hljs-keyword">auto</span> current_node = root_;<br><br>  <span class="hljs-comment">// Walk through the trie following the key characters</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : key) &#123;<br>    <span class="hljs-keyword">if</span> (current_node == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> it = current_node-&gt;children_.<span class="hljs-built_in">find</span>(c);<br>    <span class="hljs-keyword">if</span> (it == current_node-&gt;children_.<span class="hljs-built_in">end</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    current_node = it-&gt;second;<br>  &#125;<br><br>  <span class="hljs-comment">// Check if we found a node and if it has a value</span><br>  <span class="hljs-keyword">if</span> (current_node == <span class="hljs-literal">nullptr</span> || !current_node-&gt;is_value_node_) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Try to cast to the expected type</span><br>  <span class="hljs-keyword">auto</span> node_with_value = <span class="hljs-keyword">dynamic_cast</span>&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;T&gt;*&gt;(current_node.<span class="hljs-built_in">get</span>());<br>  <span class="hljs-keyword">if</span> (node_with_value == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// Type mismatch</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> node_with_value-&gt;value_.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Put(key, value) → Insert&#x2F;update (creates new trie)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Trie::Put</span><span class="hljs-params">(std::string_view key, T value)</span> <span class="hljs-type">const</span> -&gt; Trie </span>&#123;<br>  <span class="hljs-comment">// Note that `T` might be a non-copyable type. Always use `std::move` when creating `shared_ptr` on that value.</span><br><span class="hljs-comment">//  throw NotImplementedException(&quot;Trie::Put is not implemented.&quot;);</span><br><br>  <span class="hljs-comment">// You should walk through the trie and create new nodes if necessary. If the node corresponding to the key already</span><br>  <span class="hljs-comment">// exists, you should create a new `TrieNodeWithValue`.</span><br><br>  <span class="hljs-keyword">auto</span> value_ptr = std::<span class="hljs-built_in">make_shared</span>&lt;T&gt;(std::<span class="hljs-built_in">move</span>(value));<br>  std::function&lt;std::shared_ptr&lt;<span class="hljs-type">const</span> TrieNode&gt;(std::shared_ptr&lt;<span class="hljs-type">const</span> TrieNode&gt;, std::string_view)&gt; put_recursive =<br>      [&amp;](std::shared_ptr&lt;<span class="hljs-type">const</span> TrieNode&gt; current_node, std::string_view remaining_key) -&gt; std::shared_ptr&lt;<span class="hljs-type">const</span> TrieNode&gt; &#123;<br>    <span class="hljs-comment">// Base case: we&#x27;ve consumed all characters in the key</span><br>    <span class="hljs-keyword">if</span>(remaining_key.<span class="hljs-built_in">empty</span>())&#123;<br>      <span class="hljs-keyword">if</span>(current_node == <span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-comment">// create a new TrieNode with no children</span><br>        <span class="hljs-keyword">return</span> std::make_shared&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;T&gt;&gt;(value_ptr);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// create a new TrieNodeWithValue with existing children but new/updated value</span><br>        <span class="hljs-keyword">return</span> std::make_shared&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;T&gt;&gt;(current_node-&gt;children_, value_ptr);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Recursive case: consume one character and recurse</span><br>    <span class="hljs-type">char</span> next_char = remaining_key[<span class="hljs-number">0</span>];<br>    std::string_view rest_key = remaining_key.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// Get current children (or empty map if no current node)</span><br>    std::map&lt;<span class="hljs-type">char</span>, std::shared_ptr&lt;<span class="hljs-type">const</span> TrieNode&gt;&gt; new_children;<br>    <span class="hljs-keyword">if</span>(current_node != <span class="hljs-literal">nullptr</span>) &#123;<br>      new_children = current_node-&gt;children_;<br>    &#125;<br><br>    <span class="hljs-comment">// find the child for the next character</span><br>    <span class="hljs-keyword">auto</span> child_it = new_children.<span class="hljs-built_in">find</span>(next_char); <span class="hljs-comment">// when meeting the crossroad,choose corresponding child</span><br>    std::shared_ptr&lt;<span class="hljs-type">const</span> TrieNode&gt; child_node = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span>(child_it != new_children.<span class="hljs-built_in">end</span>()) &#123;<br>      child_node = child_it-&gt;second;<br>    &#125;<br><br>    <span class="hljs-comment">// recursively process the child</span><br>    new_children[next_char] = <span class="hljs-built_in">put_recursive</span>(child_node, rest_key);<br><br><br>    <span class="hljs-comment">// return the path node here</span><br>    <span class="hljs-comment">// Create a new node with the updated children</span><br>    <span class="hljs-keyword">if</span> (current_node == <span class="hljs-literal">nullptr</span> || !current_node-&gt;is_value_node_) &#123;<br>      <span class="hljs-comment">// No current node or current node has no value -&gt; create regular TrieNode</span><br>      <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">const</span> TrieNode&gt;(std::<span class="hljs-built_in">move</span>(new_children));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Current node has a value -&gt; we need to preserve it while updating children</span><br>      <span class="hljs-comment">// We&#x27;ll try to cast to the known instantiated types and preserve the value</span><br><br>      <span class="hljs-comment">// Try uint32_t</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> node_with_uint32 = <span class="hljs-keyword">dynamic_cast</span>&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;<span class="hljs-type">uint32_t</span>&gt;*&gt;(current_node.<span class="hljs-built_in">get</span>())) &#123;<br>        <span class="hljs-keyword">return</span> std::make_shared&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;<span class="hljs-type">uint32_t</span>&gt;&gt;(std::<span class="hljs-built_in">move</span>(new_children), node_with_uint32-&gt;value_);<br>      &#125;<br>      <span class="hljs-comment">// Try uint64_t</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> node_with_uint64 = <span class="hljs-keyword">dynamic_cast</span>&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;<span class="hljs-type">uint64_t</span>&gt;*&gt;(current_node.<span class="hljs-built_in">get</span>())) &#123;<br>        <span class="hljs-keyword">return</span> std::make_shared&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;<span class="hljs-type">uint64_t</span>&gt;&gt;(std::<span class="hljs-built_in">move</span>(new_children), node_with_uint64-&gt;value_);<br>      &#125;<br>      <span class="hljs-comment">// Try std::string</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> node_with_string = <span class="hljs-keyword">dynamic_cast</span>&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;std::string&gt;*&gt;(current_node.<span class="hljs-built_in">get</span>())) &#123;<br>        <span class="hljs-keyword">return</span> std::make_shared&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;std::string&gt;&gt;(std::<span class="hljs-built_in">move</span>(new_children), node_with_string-&gt;value_);<br>      &#125;<br>      <span class="hljs-comment">// Try std::unique_ptr&lt;uint32_t&gt;</span><br>      <span class="hljs-keyword">using</span> Integer = std::unique_ptr&lt;<span class="hljs-type">uint32_t</span>&gt;;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> node_with_int_ptr = <span class="hljs-keyword">dynamic_cast</span>&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;Integer&gt;*&gt;(current_node.<span class="hljs-built_in">get</span>())) &#123;<br>        <span class="hljs-keyword">return</span> std::make_shared&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;Integer&gt;&gt;(std::<span class="hljs-built_in">move</span>(new_children), node_with_int_ptr-&gt;value_);<br>      &#125;<br>      <span class="hljs-comment">// Try MoveBlocked</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> node_with_move_blocked = <span class="hljs-keyword">dynamic_cast</span>&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;MoveBlocked&gt;*&gt;(current_node.<span class="hljs-built_in">get</span>())) &#123;<br>        <span class="hljs-keyword">return</span> std::make_shared&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;MoveBlocked&gt;&gt;(std::<span class="hljs-built_in">move</span>(new_children), node_with_move_blocked-&gt;value_);<br>      &#125;<br><br>      <span class="hljs-comment">// If none of the known types match, create a regular TrieNode (losing the value)</span><br>      <span class="hljs-comment">// This shouldn&#x27;t happen with the current explicit instantiations</span><br>      <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">const</span> TrieNode&gt;(std::<span class="hljs-built_in">move</span>(new_children));<br>    &#125;<br>  &#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>Remove(key) → Delete key (creates new trie)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Trie::Remove</span><span class="hljs-params">(std::string_view key)</span> <span class="hljs-type">const</span> -&gt; Trie </span>&#123;<br>  <span class="hljs-keyword">if</span> (root_ == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// Empty trie, nothing to remove</span><br>  &#125;<br><br>  std::function&lt;std::shared_ptr&lt;<span class="hljs-type">const</span> TrieNode&gt;(std::shared_ptr&lt;<span class="hljs-type">const</span> TrieNode&gt;, std::string_view)&gt; remove_recursive =<br>      [&amp;](std::shared_ptr&lt;<span class="hljs-type">const</span> TrieNode&gt; current_node, std::string_view remaining_key) -&gt; std::shared_ptr&lt;<span class="hljs-type">const</span> TrieNode&gt; &#123;<br><br>    <span class="hljs-comment">// If current node is null, key doesn&#x27;t exist</span><br>    <span class="hljs-keyword">if</span> (current_node == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Base case: we&#x27;ve consumed all characters in the key</span><br>    <span class="hljs-keyword">if</span> (remaining_key.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-comment">// This is the node we want to remove the value from</span><br>      <span class="hljs-keyword">if</span> (!current_node-&gt;is_value_node_) &#123;<br>        <span class="hljs-comment">// Key doesn&#x27;t exist (no value at this node)</span><br>        <span class="hljs-keyword">return</span> current_node;  <span class="hljs-comment">// Return unchanged</span><br>      &#125;<br><br>      <span class="hljs-comment">// Remove the value by converting to regular TrieNode</span><br>      <span class="hljs-keyword">if</span> (current_node-&gt;children_.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// No children, remove this node entirely</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Has children, keep as regular TrieNode without value</span><br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">const</span> TrieNode&gt;(current_node-&gt;children_);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Recursive case: consume one character and recurse</span><br>    <span class="hljs-type">char</span> next_char = remaining_key[<span class="hljs-number">0</span>];<br>    std::string_view rest_key = remaining_key.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// Find the child for the next character</span><br>    <span class="hljs-keyword">auto</span> child_it = current_node-&gt;children_.<span class="hljs-built_in">find</span>(next_char);<br>    <span class="hljs-keyword">if</span> (child_it == current_node-&gt;children_.<span class="hljs-built_in">end</span>()) &#123;<br>      <span class="hljs-comment">// Key doesn&#x27;t exist</span><br>      <span class="hljs-keyword">return</span> current_node;  <span class="hljs-comment">// Return unchanged</span><br>    &#125;<br><br>    <span class="hljs-comment">// Recursively process the child</span><br>    <span class="hljs-keyword">auto</span> new_child = <span class="hljs-built_in">remove_recursive</span>(child_it-&gt;second, rest_key);<br><br>    <span class="hljs-comment">// Create new children map</span><br>    std::map&lt;<span class="hljs-type">char</span>, std::shared_ptr&lt;<span class="hljs-type">const</span> TrieNode&gt;&gt; new_children = current_node-&gt;children_;<br><br>    <span class="hljs-keyword">if</span> (new_child == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-comment">// Child was removed, remove it from children map</span><br>      new_children.<span class="hljs-built_in">erase</span>(next_char);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Update the child</span><br>      new_children[next_char] = new_child;<br>    &#125;<br><br>    <span class="hljs-comment">// Decide what to return based on current node&#x27;s state</span><br>    <span class="hljs-keyword">if</span> (current_node-&gt;is_value_node_) &#123;<br>      <span class="hljs-comment">// Current node has a value, preserve it with updated children</span><br>      <span class="hljs-comment">// Try to cast to the known instantiated types and preserve the value</span><br><br>      <span class="hljs-comment">// Try uint32_t</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> node_with_uint32 = <span class="hljs-keyword">dynamic_cast</span>&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;<span class="hljs-type">uint32_t</span>&gt;*&gt;(current_node.<span class="hljs-built_in">get</span>())) &#123;<br>        <span class="hljs-keyword">return</span> std::make_shared&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;<span class="hljs-type">uint32_t</span>&gt;&gt;(std::<span class="hljs-built_in">move</span>(new_children), node_with_uint32-&gt;value_);<br>      &#125;<br>      <span class="hljs-comment">// Try uint64_t</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> node_with_uint64 = <span class="hljs-keyword">dynamic_cast</span>&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;<span class="hljs-type">uint64_t</span>&gt;*&gt;(current_node.<span class="hljs-built_in">get</span>())) &#123;<br>        <span class="hljs-keyword">return</span> std::make_shared&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;<span class="hljs-type">uint64_t</span>&gt;&gt;(std::<span class="hljs-built_in">move</span>(new_children), node_with_uint64-&gt;value_);<br>      &#125;<br>      <span class="hljs-comment">// Try std::string</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> node_with_string = <span class="hljs-keyword">dynamic_cast</span>&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;std::string&gt;*&gt;(current_node.<span class="hljs-built_in">get</span>())) &#123;<br>        <span class="hljs-keyword">return</span> std::make_shared&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;std::string&gt;&gt;(std::<span class="hljs-built_in">move</span>(new_children), node_with_string-&gt;value_);<br>      &#125;<br>      <span class="hljs-comment">// Try std::unique_ptr&lt;uint32_t&gt;</span><br>      <span class="hljs-keyword">using</span> Integer = std::unique_ptr&lt;<span class="hljs-type">uint32_t</span>&gt;;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> node_with_int_ptr = <span class="hljs-keyword">dynamic_cast</span>&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;Integer&gt;*&gt;(current_node.<span class="hljs-built_in">get</span>())) &#123;<br>        <span class="hljs-keyword">return</span> std::make_shared&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;Integer&gt;&gt;(std::<span class="hljs-built_in">move</span>(new_children), node_with_int_ptr-&gt;value_);<br>      &#125;<br>      <span class="hljs-comment">// Try MoveBlocked</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> node_with_move_blocked = <span class="hljs-keyword">dynamic_cast</span>&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;MoveBlocked&gt;*&gt;(current_node.<span class="hljs-built_in">get</span>())) &#123;<br>        <span class="hljs-keyword">return</span> std::make_shared&lt;<span class="hljs-type">const</span> TrieNodeWithValue&lt;MoveBlocked&gt;&gt;(std::<span class="hljs-built_in">move</span>(new_children), node_with_move_blocked-&gt;value_);<br>      &#125;<br><br>      <span class="hljs-comment">// Fallback - create regular TrieNode (shouldn&#x27;t happen with explicit instantiations)</span><br>      <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">const</span> TrieNode&gt;(std::<span class="hljs-built_in">move</span>(new_children));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Current node has no value</span><br>      <span class="hljs-keyword">if</span> (new_children.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// No value and no children, remove this node</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// No value but has children, keep as regular TrieNode</span><br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">const</span> TrieNode&gt;(std::<span class="hljs-built_in">move</span>(new_children));<br>      &#125;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">auto</span> new_root = <span class="hljs-built_in">remove_recursive</span>(root_, key);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Trie</span>(new_root);<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="TrieStore-Thread-Safe-Wrapper"><a href="#TrieStore-Thread-Safe-Wrapper" class="headerlink" title="TrieStore (Thread-Safe Wrapper)"></a>TrieStore (Thread-Safe Wrapper)</h6><p>Get(key) → Thread-safe read with ValueGuard</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">TrieStore::Get</span><span class="hljs-params">(std::string_view key)</span> -&gt; std::optional&lt;ValueGuard&lt;T&gt;&gt; </span>&#123;<br>  <span class="hljs-comment">// Pseudo-code:</span><br>  <span class="hljs-comment">// (1) Take the root lock, get the root, and release the root lock. Don&#x27;t lookup the value in the</span><br>  <span class="hljs-comment">//     trie while holding the root lock.</span><br>  Trie root_snapshot;<br>  &#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(root_lock_)</span></span>;<br>    root_snapshot = root_;<br>  &#125;<br>  <span class="hljs-comment">// (2) Lookup the value in the trie.</span><br>  <span class="hljs-type">const</span> T* value_ptr = root_snapshot.<span class="hljs-built_in">Get</span>&lt;T&gt;(key);<br><br>  <span class="hljs-comment">// (3) If the value is found, return a ValueGuard object that holds a reference to the value and the</span><br>  <span class="hljs-comment">//     root. Otherwise, return std::nullopt.</span><br>  <span class="hljs-keyword">if</span>(value_ptr == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ValueGuard</span>&lt;T&gt;(std::<span class="hljs-built_in">move</span>(root_snapshot), *value_ptr);<br><span class="hljs-comment">//  throw NotImplementedException(&quot;TrieStore::Get is not implemented.&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Put(key, value) → Thread-safe write</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TrieStore::Put</span><span class="hljs-params">(std::string_view key, T value)</span> </span>&#123;<br>  <span class="hljs-comment">// You will need to ensure there is only one writer at a time. Think of how you can achieve this.</span><br>  <span class="hljs-comment">// The logic should be somehow similar to `TrieStore::Get`.</span><br><br><br>  <span class="hljs-comment">// Acquire the write lock to ensure only one writer at a time</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">write_guard</span><span class="hljs-params">(write_lock_)</span></span>;<br><br>  <span class="hljs-comment">// Get the current root</span><br>  Trie current_root;<br>  &#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">root_guard</span><span class="hljs-params">(root_lock_)</span></span>;<br>    current_root = root_;<br>  &#125;<br><br>  <span class="hljs-comment">// Create new trie with the inserted value</span><br>  Trie new_root = current_root.<span class="hljs-built_in">Put</span>&lt;T&gt;(key, std::<span class="hljs-built_in">move</span>(value));<br><br>  <span class="hljs-comment">// Update the root</span><br>  &#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">root_guard</span><span class="hljs-params">(root_lock_)</span></span>;<br>    root_ = std::<span class="hljs-built_in">move</span>(new_root);<br>  &#125;<br><span class="hljs-comment">//  throw NotImplementedException(&quot;TrieStore::Put is not implemented.&quot;);</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>Remove(key) → Thread-safe delete</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TrieStore::Remove</span><span class="hljs-params">(std::string_view key)</span> </span>&#123;<br>  <span class="hljs-comment">// You will need to ensure there is only one writer at a time. Think of how you can achieve this.</span><br>  <span class="hljs-comment">// The logic should be somehow similar to `TrieStore::Get`.</span><br><br>  <span class="hljs-comment">// Acquire write lock to ensure only one writer at a time</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">write_guard</span><span class="hljs-params">(write_lock_)</span></span>;  <span class="hljs-comment">// to wait</span><br><br>  <span class="hljs-comment">// Get the current root</span><br>  Trie current_root;<br>  &#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">root_guard</span><span class="hljs-params">(root_lock_)</span></span>; <span class="hljs-comment">// to wait</span><br>    current_root = root_;<br>  &#125;<br><br>  <span class="hljs-comment">// Create new trie with the key removed</span><br>  Trie new_root = current_root.<span class="hljs-built_in">Remove</span>(key);<br><br>  <span class="hljs-comment">// Update the root</span><br>  &#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">root_guard</span><span class="hljs-params">(root_lock_)</span></span>; <span class="hljs-comment">// to wait</span><br>    root_ = std::<span class="hljs-built_in">move</span>(new_root);<br>  &#125;<br><span class="hljs-comment">//  throw NotImplementedException(&quot;TrieStore::Remove is not implemented.&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h6><p>The current path is located at the root of the project</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> build<br>make trie_store_test trie_store_noncopy_test<br><br><span class="hljs-comment"># Test basic functionality</span><br>./test/trie_store_test<br><br><span class="hljs-comment"># Test with non-copyable types</span><br>./test/trie_store_noncopy_test<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>bustub</div>
      <div>http://example.com/2025/06/29/bustub/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>victor holmes</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>June 29, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/06/16/CGLIB/" title="CGLIB">
                        <span class="hidden-mobile">CGLIB</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
