<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>bustub | VictorHolmes Blog</title><meta name="author" content="victor holmes"><meta name="copyright" content="victor holmes"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Project 0 Primer1. C++ basicstd::string vs std::string_viewstd::stringkeys of features  dynamic memory allocation mutable operation wide range of member functions  std::string_viewkeys of features  no">
<meta property="og:type" content="article">
<meta property="og:title" content="bustub">
<meta property="og:url" content="http://example.com/2025/06/29/bustub/index.html">
<meta property="og:site_name" content="VictorHolmes Blog">
<meta property="og:description" content="Project 0 Primer1. C++ basicstd::string vs std::string_viewstd::stringkeys of features  dynamic memory allocation mutable operation wide range of member functions  std::string_viewkeys of features  no">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-06-29T06:06:55.000Z">
<meta property="article:modified_time" content="2025-06-29T13:47:01.531Z">
<meta property="article:author" content="victor holmes">
<meta property="article:tag" content="test">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "bustub",
  "url": "http://example.com/2025/06/29/bustub/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-06-29T06:06:55.000Z",
  "dateModified": "2025-06-29T13:47:01.531Z",
  "author": [
    {
      "@type": "Person",
      "name": "victor holmes",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/06/29/bustub/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'bustub',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="VictorHolmes Blog" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">VictorHolmes Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">bustub</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">bustub</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-06-29T06:06:55.000Z" title="Created 2025-06-29 14:06:55">2025-06-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-06-29T13:47:01.531Z" title="Updated 2025-06-29 21:47:01">2025-06-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="Project-0-Primer"><a href="#Project-0-Primer" class="headerlink" title="Project 0 Primer"></a>Project 0 Primer</h3><h4 id="1-C-basic"><a href="#1-C-basic" class="headerlink" title="1. C++ basic"></a>1. C++ basic</h4><h5 id="std-string-vs-std-string-view"><a href="#std-string-vs-std-string-view" class="headerlink" title="std::string vs std::string_view"></a><em>std::string vs std::string_view</em></h5><p><strong>std::string</strong><br>keys of features</p>
<ul>
<li>dynamic memory allocation</li>
<li>mutable operation</li>
<li>wide range of member functions</li>
</ul>
<p><strong>std::string_view</strong><br>keys of features</p>
<ul>
<li>non-owing view : provide view or reference to an existing string</li>
<li>light weight and efficient : assign or copy string_view is fast cause it only need to consider the reference ,length and start position of the string</li>
<li>immutable operations : if someone just need to read the string ,should use the std::string_view</li>
</ul>
<h5 id="std-lock-guard-and-std-mutex"><a href="#std-lock-guard-and-std-mutex" class="headerlink" title="std::lock_guard and std::mutex"></a><em>std::lock_guard and std::mutex</em></h5><p><strong>std::mutex</strong><br>A std::mutex (short for “mutual exclusion”) is a synchronization primitive used to protect shared data from being accessed concurrently by multiple threads.<br>std::mutex example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();  <span class="comment">// Lock the mutex</span></span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();  <span class="comment">// Unlock the mutex</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 2&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>std::lock_guard</strong><br>std::lock_guard is a RAII-style (Resource Acquisition Is Initialization) wrapper for std::mutex. It automatically locks the mutex when it’s constructed and unlocks it when it goes out of scope.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;  <span class="comment">// Mutex is locked here</span></span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// Mutex will automatically be unlocked when guard goes out of scope</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 2&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Generate-executable-program"><a href="#Generate-executable-program" class="headerlink" title="Generate executable program"></a>Generate executable program</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># First, git clone the project from the github or you could fork this to your own repository and then pull the project</span></span><br><span class="line">$ git <span class="built_in">clone</span> --bare https://github.com/cmu-db/bustub.git bustub-public</span><br><span class="line"></span><br><span class="line"><span class="comment"># Second, go to the directory of the repository,the name if not fixed if you pull your own project</span></span><br><span class="line">$ <span class="built_in">cd</span> bustub-public</span><br><span class="line"></span><br><span class="line"><span class="comment"># Third, build the project</span></span><br><span class="line">$ <span class="built_in">mkdir</span> build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>

<p>when on the third step,you could meet some problem which i met in my mac computer which is located at the third_party directory under the project root path.The detail is that the minimum version of the makefile should be 3.5 rather than 3.0. This problem only occur in my mac,but when it build in the linux, it disappear.</p>
<p><img src="/2025/06/29/bustub/buildProblem.png" alt="build-problem"></p>
<h4 id="Primer-level"><a href="#Primer-level" class="headerlink" title="Primer level"></a>Primer level</h4><p>This conclude the basic structure of the project which contains Trie ,SkipList, Hyperloglog, ORSet</p>
<h5 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h5><p>Tries — or prefix trees — are useful for sequential word search. Common features like autocomplete or spell-checking are more efficient when implemented with a prefix tree.</p>
<p>Here’s the structure of Tries:<br><img src="/2025/06/29/bustub/trie-example.png" alt="trie-structure"></p>
<p>Trie Implementation</p>
<h6 id="Core-Trie-Immutable"><a href="#Core-Trie-Immutable" class="headerlink" title="Core Trie (Immutable)"></a>Core Trie (Immutable)</h6><p>The path is as following:<br><img src="/2025/06/29/bustub/trie_path.png" alt="trie source path"></p>
<ul>
<li>Get(key) → Find value by key</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Trie::Get</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; <span class="type">const</span> T * </span>&#123;</span><br><span class="line">  <span class="comment">// Start from root</span></span><br><span class="line">  <span class="keyword">auto</span> current_node = root_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Walk through the trie following the key characters</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> c : key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = current_node-&gt;children_.<span class="built_in">find</span>(c);</span><br><span class="line">    <span class="keyword">if</span> (it == current_node-&gt;children_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current_node = it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if we found a node and if it has a value</span></span><br><span class="line">  <span class="keyword">if</span> (current_node == <span class="literal">nullptr</span> || !current_node-&gt;is_value_node_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try to cast to the expected type</span></span><br><span class="line">  <span class="keyword">auto</span> node_with_value = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;T&gt;*&gt;(current_node.<span class="built_in">get</span>());</span><br><span class="line">  <span class="keyword">if</span> (node_with_value == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// Type mismatch</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> node_with_value-&gt;value_.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Put(key, value) → Insert&#x2F;update (creates new trie)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Trie::Put</span><span class="params">(std::string_view key, T value)</span> <span class="type">const</span> -&gt; Trie </span>&#123;</span><br><span class="line">  <span class="comment">// Note that `T` might be a non-copyable type. Always use `std::move` when creating `shared_ptr` on that value.</span></span><br><span class="line"><span class="comment">//  throw NotImplementedException(&quot;Trie::Put is not implemented.&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// You should walk through the trie and create new nodes if necessary. If the node corresponding to the key already</span></span><br><span class="line">  <span class="comment">// exists, you should create a new `TrieNodeWithValue`.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> value_ptr = std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">  std::function&lt;std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;(std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;, std::string_view)&gt; put_recursive =</span><br><span class="line">      [&amp;](std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; current_node, std::string_view remaining_key) -&gt; std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; &#123;</span><br><span class="line">    <span class="comment">// Base case: we&#x27;ve consumed all characters in the key</span></span><br><span class="line">    <span class="keyword">if</span>(remaining_key.<span class="built_in">empty</span>())&#123;</span><br><span class="line">      <span class="keyword">if</span>(current_node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// create a new TrieNode with no children</span></span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;T&gt;&gt;(value_ptr);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// create a new TrieNodeWithValue with existing children but new/updated value</span></span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;T&gt;&gt;(current_node-&gt;children_, value_ptr);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursive case: consume one character and recurse</span></span><br><span class="line">    <span class="type">char</span> next_char = remaining_key[<span class="number">0</span>];</span><br><span class="line">    std::string_view rest_key = remaining_key.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Get current children (or empty map if no current node)</span></span><br><span class="line">    std::map&lt;<span class="type">char</span>, std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;&gt; new_children;</span><br><span class="line">    <span class="keyword">if</span>(current_node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      new_children = current_node-&gt;children_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the child for the next character</span></span><br><span class="line">    <span class="keyword">auto</span> child_it = new_children.<span class="built_in">find</span>(next_char); <span class="comment">// when meeting the crossroad,choose corresponding child</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; child_node = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(child_it != new_children.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      child_node = child_it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursively process the child</span></span><br><span class="line">    new_children[next_char] = <span class="built_in">put_recursive</span>(child_node, rest_key);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the path node here</span></span><br><span class="line">    <span class="comment">// Create a new node with the updated children</span></span><br><span class="line">    <span class="keyword">if</span> (current_node == <span class="literal">nullptr</span> || !current_node-&gt;is_value_node_) &#123;</span><br><span class="line">      <span class="comment">// No current node or current node has no value -&gt; create regular TrieNode</span></span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> TrieNode&gt;(std::<span class="built_in">move</span>(new_children));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Current node has a value -&gt; we need to preserve it while updating children</span></span><br><span class="line">      <span class="comment">// We&#x27;ll try to cast to the known instantiated types and preserve the value</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Try uint32_t</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_uint32 = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;<span class="type">uint32_t</span>&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;<span class="type">uint32_t</span>&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_uint32-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try uint64_t</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_uint64 = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;<span class="type">uint64_t</span>&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;<span class="type">uint64_t</span>&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_uint64-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try std::string</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_string = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;std::string&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;std::string&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_string-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try std::unique_ptr&lt;uint32_t&gt;</span></span><br><span class="line">      <span class="keyword">using</span> Integer = std::unique_ptr&lt;<span class="type">uint32_t</span>&gt;;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_int_ptr = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;Integer&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;Integer&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_int_ptr-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try MoveBlocked</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_move_blocked = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;MoveBlocked&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;MoveBlocked&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_move_blocked-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If none of the known types match, create a regular TrieNode (losing the value)</span></span><br><span class="line">      <span class="comment">// This shouldn&#x27;t happen with the current explicit instantiations</span></span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> TrieNode&gt;(std::<span class="built_in">move</span>(new_children));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Remove(key) → Delete key (creates new trie)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Trie::Remove</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; Trie </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// Empty trie, nothing to remove</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::function&lt;std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;(std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;, std::string_view)&gt; remove_recursive =</span><br><span class="line">      [&amp;](std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; current_node, std::string_view remaining_key) -&gt; std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If current node is null, key doesn&#x27;t exist</span></span><br><span class="line">    <span class="keyword">if</span> (current_node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Base case: we&#x27;ve consumed all characters in the key</span></span><br><span class="line">    <span class="keyword">if</span> (remaining_key.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="comment">// This is the node we want to remove the value from</span></span><br><span class="line">      <span class="keyword">if</span> (!current_node-&gt;is_value_node_) &#123;</span><br><span class="line">        <span class="comment">// Key doesn&#x27;t exist (no value at this node)</span></span><br><span class="line">        <span class="keyword">return</span> current_node;  <span class="comment">// Return unchanged</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Remove the value by converting to regular TrieNode</span></span><br><span class="line">      <span class="keyword">if</span> (current_node-&gt;children_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// No children, remove this node entirely</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Has children, keep as regular TrieNode without value</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> TrieNode&gt;(current_node-&gt;children_);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursive case: consume one character and recurse</span></span><br><span class="line">    <span class="type">char</span> next_char = remaining_key[<span class="number">0</span>];</span><br><span class="line">    std::string_view rest_key = remaining_key.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the child for the next character</span></span><br><span class="line">    <span class="keyword">auto</span> child_it = current_node-&gt;children_.<span class="built_in">find</span>(next_char);</span><br><span class="line">    <span class="keyword">if</span> (child_it == current_node-&gt;children_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="comment">// Key doesn&#x27;t exist</span></span><br><span class="line">      <span class="keyword">return</span> current_node;  <span class="comment">// Return unchanged</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively process the child</span></span><br><span class="line">    <span class="keyword">auto</span> new_child = <span class="built_in">remove_recursive</span>(child_it-&gt;second, rest_key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create new children map</span></span><br><span class="line">    std::map&lt;<span class="type">char</span>, std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;&gt; new_children = current_node-&gt;children_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (new_child == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// Child was removed, remove it from children map</span></span><br><span class="line">      new_children.<span class="built_in">erase</span>(next_char);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Update the child</span></span><br><span class="line">      new_children[next_char] = new_child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decide what to return based on current node&#x27;s state</span></span><br><span class="line">    <span class="keyword">if</span> (current_node-&gt;is_value_node_) &#123;</span><br><span class="line">      <span class="comment">// Current node has a value, preserve it with updated children</span></span><br><span class="line">      <span class="comment">// Try to cast to the known instantiated types and preserve the value</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Try uint32_t</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_uint32 = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;<span class="type">uint32_t</span>&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;<span class="type">uint32_t</span>&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_uint32-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try uint64_t</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_uint64 = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;<span class="type">uint64_t</span>&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;<span class="type">uint64_t</span>&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_uint64-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try std::string</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_string = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;std::string&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;std::string&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_string-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try std::unique_ptr&lt;uint32_t&gt;</span></span><br><span class="line">      <span class="keyword">using</span> Integer = std::unique_ptr&lt;<span class="type">uint32_t</span>&gt;;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_int_ptr = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;Integer&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;Integer&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_int_ptr-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Try MoveBlocked</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> node_with_move_blocked = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> TrieNodeWithValue&lt;MoveBlocked&gt;*&gt;(current_node.<span class="built_in">get</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;MoveBlocked&gt;&gt;(std::<span class="built_in">move</span>(new_children), node_with_move_blocked-&gt;value_);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Fallback - create regular TrieNode (shouldn&#x27;t happen with explicit instantiations)</span></span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> TrieNode&gt;(std::<span class="built_in">move</span>(new_children));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Current node has no value</span></span><br><span class="line">      <span class="keyword">if</span> (new_children.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// No value and no children, remove this node</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No value but has children, keep as regular TrieNode</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> TrieNode&gt;(std::<span class="built_in">move</span>(new_children));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> new_root = <span class="built_in">remove_recursive</span>(root_, key);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Trie</span>(new_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="TrieStore-Thread-Safe-Wrapper"><a href="#TrieStore-Thread-Safe-Wrapper" class="headerlink" title="TrieStore (Thread-Safe Wrapper)"></a>TrieStore (Thread-Safe Wrapper)</h6><p>Get(key) → Thread-safe read with ValueGuard</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">TrieStore::Get</span><span class="params">(std::string_view key)</span> -&gt; std::optional&lt;ValueGuard&lt;T&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// Pseudo-code:</span></span><br><span class="line">  <span class="comment">// (1) Take the root lock, get the root, and release the root lock. Don&#x27;t lookup the value in the</span></span><br><span class="line">  <span class="comment">//     trie while holding the root lock.</span></span><br><span class="line">  Trie root_snapshot;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root_snapshot = root_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// (2) Lookup the value in the trie.</span></span><br><span class="line">  <span class="type">const</span> T* value_ptr = root_snapshot.<span class="built_in">Get</span>&lt;T&gt;(key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (3) If the value is found, return a ValueGuard object that holds a reference to the value and the</span></span><br><span class="line">  <span class="comment">//     root. Otherwise, return std::nullopt.</span></span><br><span class="line">  <span class="keyword">if</span>(value_ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ValueGuard</span>&lt;T&gt;(std::<span class="built_in">move</span>(root_snapshot), *value_ptr);</span><br><span class="line"><span class="comment">//  throw NotImplementedException(&quot;TrieStore::Get is not implemented.&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Put(key, value) → Thread-safe write</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieStore::Put</span><span class="params">(std::string_view key, T value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// You will need to ensure there is only one writer at a time. Think of how you can achieve this.</span></span><br><span class="line">  <span class="comment">// The logic should be somehow similar to `TrieStore::Get`.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Acquire the write lock to ensure only one writer at a time</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">write_guard</span><span class="params">(write_lock_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the current root</span></span><br><span class="line">  Trie current_root;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">root_guard</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    current_root = root_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create new trie with the inserted value</span></span><br><span class="line">  Trie new_root = current_root.<span class="built_in">Put</span>&lt;T&gt;(key, std::<span class="built_in">move</span>(value));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the root</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">root_guard</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root_ = std::<span class="built_in">move</span>(new_root);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  throw NotImplementedException(&quot;TrieStore::Put is not implemented.&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Remove(key) → Thread-safe delete</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieStore::Remove</span><span class="params">(std::string_view key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// You will need to ensure there is only one writer at a time. Think of how you can achieve this.</span></span><br><span class="line">  <span class="comment">// The logic should be somehow similar to `TrieStore::Get`.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Acquire write lock to ensure only one writer at a time</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">write_guard</span><span class="params">(write_lock_)</span></span>;  <span class="comment">// to wait</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the current root</span></span><br><span class="line">  Trie current_root;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">root_guard</span><span class="params">(root_lock_)</span></span>; <span class="comment">// to wait</span></span><br><span class="line">    current_root = root_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create new trie with the key removed</span></span><br><span class="line">  Trie new_root = current_root.<span class="built_in">Remove</span>(key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the root</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">root_guard</span><span class="params">(root_lock_)</span></span>; <span class="comment">// to wait</span></span><br><span class="line">    root_ = std::<span class="built_in">move</span>(new_root);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  throw NotImplementedException(&quot;TrieStore::Remove is not implemented.&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h6><p>The current path is located at the root of the project</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">make trie_store_test trie_store_noncopy_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># Test basic functionality</span></span><br><span class="line">./test/trie_store_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Test with non-copyable types</span></span><br><span class="line">./test/trie_store_noncopy_test</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">victor holmes</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/06/29/bustub/">http://example.com/2025/06/29/bustub/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/06/16/CGLIB/" title="CGLIB"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">CGLIB</div></div><div class="info-2"><div class="info-item-1">Proxy in JavaPreface In Java, especially within the Spring Boot framework, proxies are commonly used to implement logic such as logging, authentication, or adding new features without modifying the original class. Two common proxy techniques used for these purposes are JDK dynamic proxy and CGLIB. JDK Dynamic Proxy in javaJDK dynamic proxy is used for classes that implements interfaces, and it does not require importing any additional libraries.It works by creating a proxy instance at...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">victor holmes</div><div class="author-info-description">Hei guys, Welcome to my Blog :)</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Project-0-Primer"><span class="toc-number">1.</span> <span class="toc-text">Project 0 Primer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-C-basic"><span class="toc-number">1.1.</span> <span class="toc-text">1. C++ basic</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#std-string-vs-std-string-view"><span class="toc-number">1.1.1.</span> <span class="toc-text">std::string vs std::string_view</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#std-lock-guard-and-std-mutex"><span class="toc-number">1.1.2.</span> <span class="toc-text">std::lock_guard and std::mutex</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Generate-executable-program"><span class="toc-number">1.2.</span> <span class="toc-text">Generate executable program</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Primer-level"><span class="toc-number">1.3.</span> <span class="toc-text">Primer level</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Trie"><span class="toc-number">1.3.1.</span> <span class="toc-text">Trie</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Core-Trie-Immutable"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">Core Trie (Immutable)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#TrieStore-Thread-Safe-Wrapper"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">TrieStore (Thread-Safe Wrapper)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Test"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">Test</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/29/bustub/" title="bustub">bustub</a><time datetime="2025-06-29T06:06:55.000Z" title="Created 2025-06-29 14:06:55">2025-06-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/16/CGLIB/" title="CGLIB">CGLIB</a><time datetime="2025-06-16T06:32:40.000Z" title="Created 2025-06-16 14:32:40">2025-06-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/07/hyperloglog/" title="hyperloglog">hyperloglog</a><time datetime="2025-03-07T08:25:15.000Z" title="Created 2025-03-07 16:25:15">2025-03-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/19/HowManyBits/" title="HowManyBits">HowManyBits</a><time datetime="2024-12-19T06:00:27.000Z" title="Created 2024-12-19 14:00:27">2024-12-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/17/IsMax/" title="IsTMax">IsTMax</a><time datetime="2024-12-17T07:14:03.000Z" title="Created 2024-12-17 15:14:03">2024-12-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By victor holmes</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>